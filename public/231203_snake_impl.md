---
title: Snakeã‚²ãƒ¼ãƒ ã‚’ç§»æ¤ã—ãŸè©±
tags:
  - Spresense
private: false
updated_at: '2023-12-04T23:25:24+09:00'
id: 13bdfc7c649f42f8e489
organization_url_name: rymansat
slide: false
ignorePublish: false
---
ã“ã®è¨˜äº‹ã¯[Spresense Advent Calendar 2023](https://qiita.com/advent-calendar/2023/spresense)ã®3æ—¥ç›®ï¼ˆ12/3åˆ†ï¼‰ã§ã™ã€‚

# æ¦‚è¦
snekeã‚²ãƒ¼ãƒ ã‚’Spresenseã«ç§»æ¤ã—ã¦ã¿ãŸè¨˜äº‹ã§ã™ã€‚

<blockquote class="twitter-tweet" data-media-max-width="560"><p lang="ja" dir="ltr">Spresenseã§snakeã‚²ãƒ¼ãƒ ã—ã¦ã¿ã¾ã—ãŸã€‚<br><br>ã“ã‚Œã‹ã‚‰æŠ•ç¨¿ã™ã‚‹Qiita Advent Calender 2023 ã€Spresenseã€‘ã®12/3åˆ†ã®è¨˜äº‹ã®ãƒ†ãƒ¼ãƒã§ã™ã€‚ <a href="https://t.co/V2Coq1Hedq">pic.twitter.com/V2Coq1Hedq</a></p>&mdash; k-abe@çµ„ã¿è¾¼ã¾ã‚ŒãŸçŒ«ä½¿ã„ğŸ§™â€â™‚ï¸ (@juraruming) <a href="https://twitter.com/juraruming/status/1731679534133436634?ref_src=twsrc%5Etfw">December 4, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

# ã‚³ãƒ¼ãƒ‰
ã‚³ãƒ¼ãƒ‰ã¯GitHubãƒªãƒã‚¸ãƒˆãƒªã«ç½®ãã¾ã—ãŸã€‚

https://github.com/grace2riku/spresense_snake

# ç¢ºèªç’°å¢ƒ
## ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢
ã¤ãã®ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã§ç¢ºèªã—ã¾ã—ãŸã€‚

* Spresenseãƒ¡ã‚¤ãƒ³ãƒœãƒ¼ãƒ‰
* Spresenseæ‹¡å¼µãƒœãƒ¼ãƒ‰
* LCD ILI9341

## ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢
Spresense SDKã§ç¢ºèªã—ã¾ã—ãŸã€‚

* [spresense SDK v3.0.0 (2023/03/13)](https://developer.sony.com/develop/spresense/docs/release_sdk_ja.html)

# ç¢ºèªæ‰‹é †
ã¤ãã®æ‰‹é †ã§ç¢ºèªã—ã¾ã™ã€‚

## ç’°å¢ƒæ§‹ç¯‰
### Spresense SDK é–‹ç™ºãƒ„ãƒ¼ãƒ«ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
äº‹å‰ã«Spresense SDKã§ã®é–‹ç™º -> Spresense SDK ã‚¹ã‚¿ãƒ¼ãƒˆã‚¬ã‚¤ãƒ‰ (CLI ç‰ˆ) -> [2. é–‹ç™ºãƒ„ãƒ¼ãƒ«ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—](https://developer.sony.com/spresense/development-guides/sdk_set_up_ja.html#_%E9%96%8B%E7%99%BA%E3%83%84%E3%83%BC%E3%83%AB%E3%81%AE%E3%82%BB%E3%83%83%E3%83%88%E3%82%A2%E3%83%83%E3%83%97)ã‚’å®Ÿæ–½ã—ã€é–‹ç™ºç’°å¢ƒã‚’æ§‹ç¯‰ã—ã¦ãŠãã¾ã™ã€‚

### ãƒ¦ãƒ¼ã‚¶ã‚¢ãƒ—ãƒªã®è¿½åŠ 
Spresense SDKã§ã®é–‹ç™º -> Spresense SDK ã‚¹ã‚¿ãƒ¼ãƒˆã‚¬ã‚¤ãƒ‰ (CLI ç‰ˆ) -> 6. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ãƒ—ãƒªã®è¿½åŠ æ–¹æ³• -> [6.3. ãƒ„ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹](https://developer.sony.com/spresense/development-guides/sdk_set_up_ja.html#_%E3%83%84%E3%83%BC%E3%83%AB%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B)ã‚’å‚ç…§ã—ã€ãƒ¦ãƒ¼ã‚¶ã‚¢ãƒ—ãƒªã‚’è¿½åŠ ã—ã¾ã™ã€‚

ä»Šå›ã¯ã¤ãã®ã‚³ãƒãƒ³ãƒ‰ã§ãƒ¦ãƒ¼ã‚¶ã‚¢ãƒ—ãƒªã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚

```
tools/mkappsdir.py snake â€œsnake_commandâ€
tools/mkcmd.py -d snake snake â€œsnake_commandâ€
```

## ã‚³ãƒ³ãƒ•ã‚£ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
spresense/sdkãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§æ¬¡ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

```
tools/config.py examples/pdcurses
```

Macã®å ´åˆã€æ¬¡ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã—ãŸã€‚
```
/Users/ãƒ¦ãƒ¼ã‚¶å/spresense/sdk
```

## ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰æº–å‚™
snakeã‚²ãƒ¼ãƒ ã¯OSSã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’æµç”¨ã•ã›ã¦ã‚‚ã‚‰ã„ã¾ã™ã€‚
æµç”¨ã•ã›ã¦ã‚‚ã‚‰ã£ãŸsnakeã‚²ãƒ¼ãƒ ã®GitHubãƒªãƒã‚¸ãƒˆãƒª

https://github.com/Sheep42/ncurses-snake

ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯MITã§ã™ã€‚

snake.cã®ã‚³ãƒ¼ãƒ‰ã‚’snake/snake_main.cã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚

## ã‚³ãƒ¼ãƒ‰å¤‰æ›´
snake/snake_main.cã‚’ã¤ãã®ã‚ˆã†ã«å¤‰æ›´ã—ã¾ã™ã€‚
ä»Šå›ã¯ã‚·ãƒªã‚¢ãƒ«ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‹ã‚‰ã®ã‚­ãƒ¼å…¥åŠ›ã§ã‚¹ãƒãƒ¼ã‚¯ãŒå‹•ãå‹•ä½œã«ã—ã¾ã™ã€‚

```diff_c
#include <time.h>
-#include <ncurses.h>
+#include "graphics/curses.h"
#include <unistd.h>
#include <stdlib.h>

+#include "debug.h"
+#include <fcntl.h>

#define DELAY 30000
#define TIMEOUT 10 

/* Global Vars */
	typedef enum {
		LEFT,
		RIGHT,
		UP,
		DOWN
	} direction_type;

	typedef struct point {
		int x;
		int y;
	} point;

	int x = 0,
		y = 0,
		maxY = 0, 
		maxX = 0,
		nextX = 0,
		nextY = 0,
		tailLength = 5,
		score = 0;

	bool gameOver = false;

	direction_type currentDir = RIGHT;
	point snakeParts[255] = {};
	point food;

/* Functions */
	void createFood() {
		//Food.x is a random int between 10 and maxX - 10
		food.x = (rand() % (maxX - 20)) + 10;

		//Food.y is a random int between 5 and maxY - 5
		food.y = (rand() % (maxY - 10)) + 5;
	}
	
	void drawPart(point drawPoint) {
		mvprintw(drawPoint.y, drawPoint.x, "o");
	}

	void cursesInit() {
		initscr(); //Initialize the window
		noecho(); //Don't echo keypresses
		keypad(stdscr, TRUE);
		cbreak();
		timeout(TIMEOUT);
		curs_set(FALSE); //Don't display a cursor

		//Global var stdscr is created by the call to initscr()
		getmaxyx(stdscr, maxY, maxX);
	}

	void init() {
		srand(time(NULL));

		currentDir = RIGHT;
		tailLength = 5;
		gameOver = false;
		score = 0;

		clear(); //Clears the screen
		
		//Set the initial snake coords 
		int j = 0;
		for(int i = tailLength; i >= 0; i--) {
			point currPoint;
			
			currPoint.x = i;
			currPoint.y = maxY / 2; //Start mid screen on the y axis

			snakeParts[j] = currPoint;
			j++;
		}


		createFood();

		refresh();
	}

	void shiftSnake() {
		point tmp = snakeParts[tailLength - 1];

		for(int i = tailLength - 1; i > 0; i--) {
			snakeParts[i] = snakeParts[i-1];
		}

		snakeParts[0] = tmp;
	}

	void drawScreen() {
		//Clears the screen - put all draw functions after this
		clear(); 

		//Print game over if gameOver is true
		if(gameOver)
			mvprintw(maxY / 2, maxX / 2, "Game Over!");

		//Draw the snake to the screen
		for(int i = 0; i < tailLength; i++) {
			drawPart(snakeParts[i]);
		}

		//Draw the current food
		drawPart(food);

		//Draw the score
		mvprintw(1, 2, "Score: %i", score);

		//ncurses refresh
		refresh();

		//Delay between movements
		usleep(DELAY); 
	}

+#define SPRESENSE_MAIN_BOARD_UART_DEVICE_PATH "/dev/ttyS0"
+
+int getch_serial(int fd) {
+	int len;
+	int ch = 0;
+
+	len = read(fd, (void*)&ch, 1);
+    if(len > 0)
+    {
+		if (ch == 0x1b) {
+			read(fd, &ch, 1);
+			if (ch == 0x5b) {
+				read(fd, &ch, 1);
+				if (ch == 0x44) ch = KEY_LEFT;
+				if (ch == 0x43) ch = KEY_RIGHT;
+				if (ch == 0x41) ch = KEY_UP;
+				if (ch == 0x42) ch = KEY_DOWN;
+			}
+		}
+    }
+
+	return ch;
+}

/* Main */
	int main(int argc, char *argv[]) {
+		_info("snake main()\n");
+
+		int fd = open(SPRESENSE_MAIN_BOARD_UART_DEVICE_PATH, O_RDWR | O_NONBLOCK);
+		if (fd < 0)
+		{
+			printf("%s open error.\n", SPRESENSE_MAIN_BOARD_UART_DEVICE_PATH);
+			return 1;
+		}

		cursesInit();
		init();

		int ch;
		while(1) {
			//Global var stdscr is created by the call to initscr()
			//This tells us the max size of the terminal window at any given moment
			getmaxyx(stdscr, maxY, maxX);
			
			if(gameOver) {
				sleep(2);
				init();
			}

			/* Input Handler */
-				ch = getch();
+				ch = getch_serial(fd);

				if(( ch=='l' || ch=='L' || ch == KEY_RIGHT) && (currentDir != RIGHT && currentDir != LEFT)) {
					currentDir = RIGHT;
				} else if (( ch=='h' || ch=='H' || ch == KEY_LEFT) && (currentDir != RIGHT && currentDir != LEFT)) {
					currentDir = LEFT;
				} else if((ch=='j' || ch=='J' || ch == KEY_DOWN) && (currentDir != UP && currentDir != DOWN)) {
					currentDir = DOWN;
				} else if((ch=='k' || ch=='K' || ch == KEY_UP) && (currentDir != UP && currentDir != DOWN)) {
					currentDir = UP;
+				} else if ((ch=='q' || ch=='Q')) {
+					break;
				}

+				_info("ch = getch() char:%c, hex:%x, dec:%d\n", ch, ch, ch);

			/* Movement */
				nextX = snakeParts[0].x;
				nextY = snakeParts[0].y;

				if(currentDir == RIGHT) nextX++;
		    	else if(currentDir == LEFT) nextX--;
				else if(currentDir == UP) nextY--;
				else if(currentDir == DOWN) nextY++;

				if(nextX == food.x && nextY == food.y) {
					point tail;
					tail.x = nextX;
					tail.y = nextY;

					snakeParts[tailLength] = tail;

					if(tailLength < 255)
						tailLength++;
					else
						tailLength = 5; //If we have exhausted the array then just reset the tail length but let the player keep building their score :)

					score += 5;
					createFood();
				} else {
					//Draw the snake to the screen
					for(int i = 0; i < tailLength; i++) {
						if(nextX == snakeParts[i].x && nextY == snakeParts[i].y) {
							gameOver = true;
							break;
						}
					}

					//We are going to set the tail as the new head
					snakeParts[tailLength - 1].x = nextX;
					snakeParts[tailLength - 1].y = nextY;
				}

				//Shift all the snake parts
				shiftSnake();

				//Game Over if the player hits the screen edges
				if((nextX >= maxX || nextX < 0) || (nextY >= maxY || nextY < 0)) {
					gameOver = true;
				}

			/* Draw the screen */
				drawScreen();
		}

		endwin(); //Restore normal terminal behavior
		nocbreak();

		return 0;
	}
```

ã‚³ãƒ¼ãƒ‰ä¿®æ­£ãŒçµ‚äº†ã—ãŸã‚‰makeã€ã‚³ãƒ¼ãƒ‰ã‚’flashã—ã¾ã™ã€‚
NuttXã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆï¼ˆnshï¼‰ã‹ã‚‰snakeã¨ã‚¿ã‚¤ãƒ—ã™ã‚‹ã¨snakeã‚²ãƒ¼ãƒ ãŒå®Ÿè¡Œã§ãã¾ã™ã€‚
ä¸Šä¸‹å·¦å³ã‚­ãƒ¼ã§snakeãŒå‹•ãã¾ã™ã€‚qã‚­ãƒ¼ã§ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã—ã¾ã™ã€‚

# ãªãœç°¡å˜ã«snakeã‚²ãƒ¼ãƒ ãŒã§ããŸã®ã‹è€ƒå¯Ÿ
ã‚ªãƒªã‚¸ãƒŠãƒ«ã®snakeã‚³ãƒãƒ³ãƒ‰ã¯ncursesã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚
ncursesã®Windowså‘ã‘å®Ÿè£…PDCursesãŒNuttXï¼ˆâ€»ï¼‰ã«ãƒãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã•ã‚Œã¦ãŠã‚Šã€ä»Šå›ã¯PDCursesã‚’ä½¿ã„ã¾ã—ãŸï¼ˆã‚³ãƒ³ãƒ•ã‚£ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§examples/pdcursesã‚’æŒ‡å®šã—ãŸã¨ã“ã‚ï¼‰ã€‚

â€»Spresense SDKã¯NuttXã®ã†ãˆã§å‹•ä½œã—ã¦ã„ã¾ã™ã€‚

ä»¥å‰slã‚³ãƒãƒ³ãƒ‰ã®ç§»æ¤ã‚’è¡Œã„ã¾ã—ãŸãŒã€snakeã‚²ãƒ¼ãƒ ã‚‚ncursesã‚’ä½¿ç”¨ã—ã¦ã„ãŸã®ã§ã‚ã‚Šã¨ç°¡å˜ã«ç§»æ¤ãŒã§ãã¾ã—ãŸã€‚

slã‚³ãƒãƒ³ãƒ‰ã®ç§»æ¤

https://qiita.com/juraruming/items/fb8cdbc4d4fe6a503a08

